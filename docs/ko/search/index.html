<!DOCTYPE html>

<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">

		<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>검색 | Orb_H</title>
<meta name="generator" content="Jekyll v3.9.1" />
<meta property="og:title" content="검색" />
<meta property="og:locale" content="ko" />
<meta name="description" content="&quot;&quot;에 대한 검색 결과 대기 중..." />
<meta property="og:description" content="&quot;&quot;에 대한 검색 결과 대기 중..." />
<link rel="canonical" href="https://orb-h.github.io/projects/ko/search/" />
<meta property="og:url" content="https://orb-h.github.io/projects/ko/search/" />
<meta property="og:site_name" content="Orb_H" />
<script type="application/ld+json">
{"headline":"검색","dateModified":"2020-03-15T02:04:04+09:00","url":"https://orb-h.github.io/projects/ko/search/","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://orb-h.github.io/projects/siteicon.png"}},"@type":"Article","description":"&quot;&quot;에 대한 검색 결과 대기 중...","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

		<link type="application/atom+xml" rel="alternate" href="https://orb-h.github.io/projects/feed.xml" title="Orb_H" />

		
		
		

		<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
		<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/moonspam/NanumSquare@1.0/nanumsquare.css">
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,400italic,700,700italic|Open+Sans:400,400italic,600,600italic,700,700italic|Inconsolata:400,700">

		<script type="text/x-mathjax-config">
			MathJax.Hub.Config({
			  extensions: ["tex2jax.js"],
			  jax: ["input/TeX", "output/HTML-CSS"],
			  skipStartupTypeset: true,
			  tex2jax: {
				inlineMath: [ ['$','$'], ["\\(","\\)"] ],
				displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
				processEscapes: true
			  },
			  "HTML-CSS": { fonts: ["TeX"] }
			});
		</script>
		<script type="text/javascript"
		  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS_HTML">
	   </script>

		<link rel="stylesheet" href="/projects/css/main.css">
		<link rel="stylesheet" href="/projects/css/ko.css">
		<link rel="icon" href="/projects/images/favicon-16.png" sizes="16x16">
		<link rel="icon" href="/projects/images/favicon-32.png" sizes="32x32">
		<link rel="icon" href="/projects/images/favicon-48.png" sizes="48x48">
		<link rel="icon" href="/projects/images/favicon-57.png" sizes="57x57">
		<link rel="icon" href="/projects/images/favicon-64.png" sizes="64x64">
		<link rel="icon" href="/projects/images/favicon-72.png" sizes="72x72">
		<link rel="icon" href="/projects/images/favicon-96.png" sizes="96x96">
		<link rel="icon" href="/projects/images/favicon-120.png" sizes="120x120">
		<link rel="icon" href="/projects/images/favicon-128.png" sizes="128x128">
		<link rel="icon" href="/projects/images/favicon-144.png" sizes="144x144">
		<link rel="icon" href="/projects/images/favicon-152.png" sizes="152x152">
		<link rel="icon" href="/projects/images/favicon-195.png" sizes="195x195">
		<link rel="icon" href="/projects/images/favicon-228.png" sizes="228x228">
		<link rel="icon" href="/projects/images/favicon-256.png" sizes="256x256">
		<link rel="icon" href="/projects/images/favicon-480.png" sizes="480x480">

		
	</head>

	<body>
		<header>
			<h1>
				<a href="/projects/ko"><img src="/projects/images/emblem.png" width="40px" height="40px" alt="Orb_H logo"></a>
				Orb_H
				<button type="button" class="open-nav" id="open-nav"></button>
			</h1>

			<form action="/projects/ko/search/" method="get">
				<input type="text" name="q" id="search-input" placeholder="검색..." autofocus>
				<input type="submit" value="Search" style="display: none;">
			</form>

			<nav class="full-navigation">
				<ul>
					<li class="nav-item top-level">
						<a href="/projects/ko/">메인 페이지</a>
					</li>
				</ul>

				<ul>
					
					
					
					
					
						<li class="nav-item top-level">
							
							
							<a href="/projects/ko/2016/titration">2016</a>
							<ul>
								
									<li class="nav-item"><a href="/projects/ko/2016/titration">산-염기 적정 시뮬레이션</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level">
							
							
							<a href="/projects/ko/2019/plcomp">2019</a>
							<ul>
								
									<li class="nav-item"><a href="/projects/ko/2019/plcomp">프로그래밍언어 최종 과제</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level">
							
                        		
				</ul>

				<ul>
					<li class="nav-item top-level">
						<a>외부 링크</a>
						<ul>
							<li class="nav-item">
								<a href="https://orb-h.github.io/ko/">루트 페이지</a>
							</li>
							<li class="nav-item">
								<a href="https://orb-h.github.io/resume/ko/">이력서</a>
							</li>
							<li class="nav-item">
								<a href="https://orb-h.github.io/blog/ko/">블로그</a>
							</li>
							<li class="nav-item">
								<a href="https://github.com/CloudCannon/edition-jekyll-template"><b>테마 리포지토리</b></a>
							</li>
						</ul>
					</li>
				</ul>
			</nav>
		</header>

		<section class="main">
			<div class="page-header">
				<h2>Orb_H</h2>
				<h3>검색</h3>
				<div align="right">
					
						
						한국어
						 / 
						<a href="/projects/en/search/search">English</a>
						
					
				</div>
			</div>
			<article class="content">
				<p><span id="search-query-container" style="display: none;">"<strong id="search-query"></strong>"에 대한 </span>검색 결과<span id="search-process"> 대기 중...</span></p>

<ul id="search-results"></ul>

<script>
	window.data = {
		
		
			
				
					
					

					"ko-2016-titration-equation": {
						"id": "ko-2016-titration-equation",
						"title": "산-염기 적정 시뮬레이션/방정식 유도",
						"category": "",
						"url": " /ko/2016/titration/equation",
						"content": "방정식 유도 분석화학 기법을 사용하여 적정 실험을 분석한 내용을 수소 이온의 농도 $\\left[H^+\\right]=x$와 첨가한 표준 용액의 부피 $v$에 대한 방정식으로 유도하는 과정이다. 1가 산-1가 염기 농도를 식으로 변환 원문에 따르면 얻은 방정식은 아래와 같다. \\[\\left[H^+\\right]+\\left[BH^+\\right]=\\left[A^-\\right]+\\left[OH^-\\right]\\\\ \\left[HA\\right]_0=\\left[HA\\right]+\\left[A^-\\right]\\\\ \\left[B\\right]_0=\\left[B\\right]+\\left[BH^+\\right]\\\\ K_a=\\frac{\\left[H^+\\right]\\left[A^-\\right]}{\\left[HA\\right]}\\\\ K_b=\\frac{\\left[BH^+\\right]\\left[OH^-\\right]}{\\left[B\\right]}\\\\\\] 그리고 미지 용액 $VmL$에 표준 용액 $vmL$를 첨가한 상태를 가정할 것이므로 해당 시점에서 HA와 A-의 농도의 합은 $\\frac{V}{V+v}\\left[HA\\right]_0$이다. 또한 B와 BH+의 농도의 합은 $\\frac{v}{V+v}\\left[B\\right]_0$이다. 이제 식을 유도하는 과정을 간단하게 하기 위해 일부 식을 문자로 치환한다. \\[\\begin{aligned} K_a&amp;\\rightarrow a\\\\ K_b&amp;\\rightarrow b\\\\ K_w&amp;\\rightarrow w\\\\ \\frac{V}{V+v}\\left[HA\\right]_0&amp;\\rightarrow A\\\\ \\frac{v}{V+v}\\left[B\\right]_0&amp;\\rightarrow B\\\\ \\left[H^+\\right]&amp;\\rightarrow x\\\\ \\left[OH^-\\right]&amp;\\rightarrow y=\\frac{w}{x} \\end{aligned}\\] 먼저 이온화 상수와 질량 균형을 사용하여 A, B와 관련된 화학종의 농도를 식으로 표현한다. \\[\\begin{aligned} a&amp;=\\frac{x\\left[A^-\\right]}{\\left[HA\\right]}\\\\ a\\left[HA\\right]&amp;=x\\left[A^-\\right]\\\\ a(A-\\left[A^-\\right])&amp;=x\\left[A^-\\right]\\\\ \\left[A^-\\right]&amp;=\\frac{Aa}{x+a}\\\\ \\left[HA\\right]&amp;=A-\\left[A^-\\right]\\\\ &amp;=\\frac{Ax}{x+a} \\end{aligned}\\] 같은 방식으로, $\\left[BH^+\\right]=\\frac{Bb}{y+b}$, $\\left[B\\right]=\\frac{By}{y+b}$가 된다. 방정식 유도 앞에서 구한 식을 사용하여 전하 균형식을 수소 이온 농도에 대한 다항방정식으로 유도한다. \\[\\begin{aligned} \\left[H^+\\right]+\\left[BH^+\\right]&amp;=\\left[OH^-\\right]+\\left[A^-\\right]\\\\ x+\\frac{Bb}{y+b}&amp;=y+\\frac{Aa}{x+a}\\\\ x+\\frac{Bbx}{w+bx}&amp;=\\frac{w}{x}+\\frac{Aa}{x+a} \\end{aligned}\\] 위 식의 분모에 있는 모든 식을 곱하여 분수를 없앤다. \\[\\begin{aligned} &amp;x^2(x+a)(w+bx)+Bbx^2(x+a)\\\\ &amp;=w(x+a)(w+bx)+Aax(w+bx) \\end{aligned}\\] 모두 정리한 후 좌변으로 모든 항을 옮기고 x의 차수에 따라 계수를 정리한다. \\[\\begin{aligned} &amp;bx^4+(ab+w)x^3+awx^2+Bbx^3+aBbx^2\\\\ &amp;-bwx^2-(ab+w)wx-aw^2-Aabx^2-Aawx=0 \\end{aligned}\\\\ \\begin{aligned} &amp;bx^4+(ab+w+Bb)x^3+(aw+aBb-bw-Aab)x^2\\\\ &amp;-(abw+w^2+Aaw)x-aw^2=0 \\end{aligned}\\] 양변을 b로 나누어 최고차항의 계수를 1로 만든다. 여기서 $b’=\\frac{w}{b}$로 정의한다. \\[\\begin{aligned} &amp;x^4+(a+b'+B)x^3+(ab'+aB-w-Aa)x^2\\\\ &amp;-(aw+b'w+Aab')x-ab'w=0 \\end{aligned}\\] 2가 산-1가 염기 농도를 식으로 변환 원문에 따르면 얻은 방정식은 아래와 같다. \\[\\left[H^+\\right]+\\left[BH^+\\right]=\\left[HA^-\\right]+2\\left[A^{2-}\\right]+\\left[OH^-\\right]\\\\ \\left[H_2A\\right]_0=\\left[H_2A\\right]+\\left[HA^-\\right]+\\left[A^{2-}\\right]\\\\ \\left[B\\right]_0=\\left[B\\right]+\\left[BH^+\\right]\\\\ K_{a1}=\\frac{\\left[H^+\\right]\\left[HA^-\\right]}{\\left[H_2A\\right]}\\\\ K_{a2}=\\frac{\\left[H^+\\right]\\left[A^{2-}\\right]}{\\left[HA^-\\right]}\\\\ K_b=\\frac{\\left[BH^+\\right]\\left[OH^-\\right]}{\\left[B\\right]}\\] 그리고 위 경우와 마찬가지로 미지 용액 $VmL$에 표준 용액 $vmL$를 첨가한 상태를 가정할 것이므로 A 관련 화학종의 농도 합은 $\\frac{V}{V+v}\\left[H_2A\\right]_0$, B 관련 화학종의 농도 합은 $\\frac{v}{V+v}\\left[B\\right]_0$이다. 이제 식을 유도하는 과정을 간단하게 하기 위해 일부 식을 문자로 치환한다. \\[\\begin{aligned} K_{a1}&amp;\\rightarrow a\\\\ K_{a2}&amp;\\rightarrow a'\\\\ K_b&amp;\\rightarrow b\\\\ K_w&amp;\\rightarrow w\\\\ \\frac{V}{V+v}\\left[H_2A\\right]_0&amp;\\rightarrow A\\\\ \\frac{v}{V+v}\\left[B\\right]_0&amp;\\rightarrow B\\\\ \\left[H^+\\right]&amp;\\rightarrow x\\\\ \\left[OH^-\\right]&amp;\\rightarrow y=\\frac{w}{x} \\end{aligned}\\] 이온화 상수와 질량 균형을 사용하여 A, B와 관련된 화학종의 농도를 식으로 표현한다. \\[\\text{Let }\\alpha=\\left[HA^-\\right],\\beta=\\left[A^{2-}\\right]\\\\ \\rightarrow \\left[H_2A\\right]=A-\\alpha-\\beta\\\\ \\begin{aligned} a&amp;=\\frac{x\\alpha}{A-\\alpha-\\beta}\\\\ a'&amp;=\\frac{x\\beta}{\\alpha}\\\\ \\beta&amp;=\\frac{a'\\alpha}{x}\\\\ a(A-\\alpha-\\frac{a'\\alpha}{x})&amp;=x\\alpha\\\\ Aax-a\\alpha x-aa'\\alpha&amp;=x^2\\alpha\\\\ \\alpha&amp;=\\frac{Aax}{x^2+ax+aa'}\\\\ \\beta&amp;=\\frac{a'\\alpha}{x}\\\\ &amp;=\\frac{Aaa'}{x^2+ax+aa'} \\end{aligned}\\] 그리고 염기는 그대로 1가이므로 $[BH^+]=\\frac{Bb}{y+b}$, $[B]=\\frac{By}{y+b}$이다. 방정식 유도 앞에서 구한 식을 사용하여 전하 균형식을 수소 이온 농도에 대한 다항방정식으로 유도한다. \\[\\begin{aligned} \\left[H^+\\right]+\\left[BH^+\\right]&amp;=\\left[OH^-\\right]+\\left[HA^-\\right]+2\\left[A^{2-}\\right]\\\\ x+\\frac{Bb}{y+b}&amp;=y+\\frac{Aax}{x^2+ax+aa'}+2\\frac{Aaa'}{x^2+ax+aa'}\\\\ x+\\frac{Bbx}{w+bx}&amp;=\\frac{w}{x}+\\frac{Aax}{x^2+ax+aa'}+2\\frac{Aaa'}{x^2+ax+aa'} \\end{aligned}\\] 위 식의 분모에 있는 모든 식을 곱하여 분수를 없앤다. \\[\\begin{aligned} &amp;x^2(x^2+ax+aa')(w+bx)+Bbx^2(x^2+ax+aa')\\\\ &amp;=w(x^2+ax+aa')(w+bx)+Aa(x+a')x(w+bx) \\end{aligned}\\] 모두 정리한 후 좌변으로 모든 항을 옮기고 x의 차수에 따라 계수를 정리한다. \\[\\begin{aligned} &amp;bx^5+abx^4+wx^4+aa'bx^3+awx^3+aa'wx^2\\\\ &amp;+Bbx^4+aBbx^3+aa'Bbx^2-bwx^3-abwx^2\\\\ &amp;-w^2x^2-aa'bwx-aw^2x-aa'w^2\\\\ &amp;-Aabx^3-Aawx^2-Aaa'bx^2-Aaa'wx=0 \\end{aligned}\\\\ \\begin{aligned} &amp;bx^5+(ab+Bb+w)x^4+(aa'b+aw+aBb-bw-Aab)x^3\\\\ &amp;+(aa'w+aa'Bb-abw-w^2-Aaw-Aaa'b)x^2\\\\ &amp;-(aa'bw+aw^2+Aaa'w)x-aa'w^2=0 \\end{aligned}\\] 양변을 b로 나누어 최고차항의 계수를 1로 만든다. 마찬가지로 $b’=\\frac{w}{b}$로 정의한다. \\[\\begin{aligned} &amp;x^5+(a+b'+B)x^4+(aa'+ab'+aB-w-Aa)x^3\\\\ &amp;+(aa'b'+aa'B-aw-b'w-Aab'-Aaa')x^2\\\\ &amp;-(aa'w+ab'w+Aaa'b')x-aa'b'w=0 \\end{aligned}\\] 3가 산-1가 염기 농도를 식으로 변환 원문에 따르면 얻은 방정식은 아래와 같다. \\[\\begin{aligned} &amp;\\left[H^+\\right]+\\left[BH^+\\right]\\\\ &amp;=\\left[H_2A^-\\right]+2\\left[HA^{2-}\\right]+3\\left[A^{3-}\\right]+\\left[OH^-\\right] \\end{aligned}\\\\ \\left[H_3A\\right]_0=\\left[H_3A\\right]+\\left[H_2A^-\\right]+\\left[HA^{2-}\\right]+\\left[A^{3-}\\right]\\\\ \\left[B\\right]_0=\\left[B\\right]+\\left[BH^+\\right]\\\\ K_{a1}=\\frac{\\left[H^+\\right]\\left[H_2A^-\\right]}{\\left[H_3A\\right]}\\\\ K_{a2}=\\frac{\\left[H^+\\right]\\left[HA^{2-}\\right]}{\\left[H_2A^-\\right]}\\\\ K_{a3}=\\frac{\\left[H^+\\right]\\left[A^{3-}\\right]}{\\left[HA^{2-}\\right]}\\\\ K_b=\\frac{\\left[BH^+\\right]\\left[OH^-\\right]}{\\left[B\\right]}\\] 마찬가지로 미지 용액 $VmL$에 표준 용액 $vmL$를 첨가한 상태를 가정할 것이므로 A 관련 화학종의 농도 합은 $\\frac{V}{V+v}\\left[H_3A\\right]_0$, B 관련 화학종의 농도 합은 $\\frac{v}{V+v}\\left[B\\right]_0$이다. 이제 식을 유도하는 과정을 간단하게 하기 위해 일부 식을 문자로 치환한다. \\[\\begin{aligned} K_{a1}&amp;\\rightarrow a\\\\ K_{a2}&amp;\\rightarrow a'\\\\ K_{a3}&amp;\\rightarrow a''\\\\ K_b&amp;\\rightarrow b\\\\ K_w&amp;\\rightarrow w\\\\ \\frac{V}{V+v}\\left[H_3A\\right]_0&amp;\\rightarrow A\\\\ \\frac{v}{V+v}\\left[B\\right]_0&amp;\\rightarrow B\\\\ \\left[H^+\\right]&amp;\\rightarrow x\\\\ \\left[OH^-\\right]&amp;\\rightarrow y=\\frac{w}{x} \\end{aligned}\\] 이온화 상수와 질량 균형을 사용하여 A, B와 관련된 화학종의 농도를 식으로 표현한다. \\[\\text{Let }\\alpha=\\left[H_2A^-\\right],\\beta=\\left[HA^{2-}\\right],\\gamma=\\left[A^{3-}\\right]\\\\ \\rightarrow \\left[H_3A\\right]=A-\\alpha-\\beta-\\gamma\\\\ \\begin{aligned} a&amp;=\\frac{x\\alpha}{A-\\alpha-\\beta-\\gamma}\\\\ a'&amp;=\\frac{x\\beta}{\\alpha}\\\\ a''&amp;=\\frac{x\\gamma}{\\beta}\\\\ \\beta&amp;=\\frac{a'\\alpha}{x}\\\\ \\gamma&amp;=\\frac{a''\\beta}{x}\\\\ a(A-\\alpha-\\frac{a'\\alpha}{x}-\\frac{a'a''\\alpha}{x^2})&amp;=x\\alpha\\\\ Aax^2-a\\alpha x^2-aa'\\alpha x-aa'a''&amp;=x^3\\alpha\\\\ \\alpha&amp;=\\frac{Aax^2}{x^3+ax^2+aa'x+aa'a''}\\\\ \\beta&amp;=\\frac{a'\\alpha}{x}\\\\ &amp;=\\frac{Aaa'x}{x^3+ax^2+aa'x+aa'a''}\\\\ \\gamma&amp;=\\frac{a''\\beta}{x}\\\\ &amp;=\\frac{Aaa'a''}{x^3+ax^2+aa'x+aa'a''} \\end{aligned}\\] 그리고 염기는 그대로 1가이므로 $[BH^+]=\\frac{Bb}{y+b}$, $[B]=\\frac{By}{y+b}$이다. 방정식 유도 앞에서 구한 식을 사용하여 전하 균형식을 수소 이온 농도에 대한 다항방정식으로 유도한다. \\[\\begin{aligned} \\left[H^+\\right]+\\left[BH^+\\right]&amp;=\\left[OH^-\\right]+\\left[H_2A^-\\right]\\\\ &amp;+2\\left[HA^{2-}\\right]+3\\left[A^{3-}\\right]\\\\ x+\\frac{Bb}{y+b}&amp;=y+\\frac{Aax^2}{x^3+ax^2+aa'x+aa'a''}\\\\ &amp;+2\\frac{Aaa'x}{x^3+ax^2+aa'x+aa'a''}+3\\frac{Aaa'a''}{x^3+ax^2+aa'x+aa'a''}\\\\ x+\\frac{Bbx}{w+bx}&amp;=\\frac{w}{x}+\\frac{Aax^2}{x^3+ax^2+aa'x+aa'a''}\\\\ &amp;+2\\frac{Aaa'x}{x^3+ax^2+aa'x+aa'a''}+3\\frac{Aaa'a''}{x^3+ax^2+aa'x+aa'a''} \\end{aligned}\\] 위 식의 분모에 있는 모든 식을 곱하여 분수를 없앤다. \\[\\begin{aligned} &amp;x^2(x^3+ax^2+aa'x+aa'a'')(w+bx)+Bbx^2(x^3+ax^2+aa'x+aa'a'')\\\\ &amp;=w(x^3+ax^2+aa'x+aa'a'')(w+bx)+Aa(x^2+a'x+a'a'')x(w+bx) \\end{aligned}\\] 모두 정리한 후 좌변으로 모든 항을 옮기고 x의 차수에 따라 계수를 정리한다. \\[\\begin{aligned} &amp;bx^6+abx^5+wx^5+awx^4+aa'bx^4+aa'w^3+aa'a''bx^3+aa'a''wx^2\\\\ &amp;+Bbx^5+aBbx^4+aa'Bbx^3+aa'a''Bbx^2\\\\ &amp;-bx^4-abwx^3-w^2x^3-aa'bwx^2-aw^2x^2-aa'a''bwx-aa'w^2x-aa'a''w^2\\\\ &amp;-aAbx^4-aAwx^3-2aa'Abx^3-2aa'Awx^2-3aa'a''Abx^2-3aa'a''Awx=0 \\end{aligned}\\\\ \\begin{aligned} &amp;bx^6+(ab+w+Bb)x^5+(aw+aa'b+aBb-bw-aAb)x^4\\\\ &amp;+(aa'w+aa'a''b+aa'Bb-abw-w^2-aAw-2aa'Ab)x^3\\\\ &amp;+(aa'a''w+aa'a''Bb-aa'bw-aw^2-2aa'Aw-3aa'a''Ab)x^2\\\\ &amp;-(aa'a''bw+aa'w^2+3aa'a''Aw)x-aa'a''w^2=0 \\end{aligned}\\] 양변을 b로 나누어 최고차항의 계수를 1로 만든다. 마찬가지로 $b’=\\frac{w}{b}$로 정의한다. \\[\\begin{aligned} &amp;x^6+(a+b'+B)x^5+(aa'+ab'+aB-w-aA)x^4\\\\ &amp;+(aa'b'+aa'a''+aa'B-aw-b'w-aAb'-2aa'A)x^3\\\\ &amp;+(aa'a''b'+aa'a''B-aa'w-ab'w-2aa'Ab'-3aa'a''A)x^2\\\\ &amp;-(aa'a''w+aa'b'w+3aa'a''Ab')x-aa'a''b'w=0 \\end{aligned}\\] 그래프의 기울기 편미분을 사용하여 x축이 표준 용액의 부피, y축이 pH인 그래프의 기울기를 구하는 과정이다. 위에서 구한 방정식은 모두 수소 이온 농도 x와 첨가한 표준 용액의 부피 v에 대한 방정식이므로 이를 사용하여 적정 그래프의 기울기를 구할 수 있을 것이다. 기울기를 구하려고 하는 경우의 방정식을 $f(x,v)=0$로 쓴다고 하면 아래와 같이 된다. \\[f(x,v)=0\\\\ df(x,v)=0\\\\ \\frac{\\partial f}{\\partial x}dx+\\frac{\\partial f}{\\partial v}dv=0\\\\ \\frac{\\partial f}{\\partial x}dx=-\\frac{\\partial f}{\\partial v}dv\\\\ \\frac{dx}{dv}=-\\frac{\\frac{\\partial f}{\\partial v}}{\\frac{\\partial f}{\\partial x}}\\] 그래프의 기울기는 (y축 변화량) (x축 변화량)으로 주어지는데, 적정 실험과 같은 그래프에서는 x축에 표준 용액의 부피, y축에 pH가 들어간다. 이를 전개해보면 아래와 같다. \\[\\begin{aligned} m&amp;=\\frac{dpH}{dv}\\\\ &amp;=\\frac{d(-\\log_{10}{x})}{dv}\\\\ &amp;=\\frac{-\\frac{1}{x\\ln{10}}dx}{dv}\\\\ &amp;=-\\frac{1}{x\\ln{10}}\\frac{dx}{dv}\\\\ &amp;=\\frac{1}{x\\ln{10}}\\frac{\\frac{\\partial f}{\\partial v}}{\\frac{\\partial f}{\\partial x}} \\end{aligned}\\] 1가 산-1가 염기 위에서 얻은 방정식을 가져와보면 아래와 같다. \\[\\begin{aligned} &amp;x^4+(a+b'+B)x^3+(ab'+aB-w-Aa)x^2\\\\ &amp;-(aw+b'w+Aab')x-ab'w=0 \\end{aligned}\\] 위 방정식을 f1,1=0이라고 나타내면 기울기는 아래와 같다. \\[\\begin{aligned} \\frac{dpH}{dv}&amp;=\\frac{d(-\\log_{10}{x})}{dv}=\\frac{1}{x\\ln{10}}\\frac{\\frac{\\partial f_{1,1}}{\\partial v}}{\\frac{\\partial f_{1,1}}{\\partial x}}\\\\ \\frac{\\partial f_{1,1}}{\\partial v}&amp;=\\frac{\\partial A}{\\partial v}(-ax^2-ab'x)+\\frac{\\partial B}{\\partial v}(x^3+ax^2)\\\\ \\frac{\\partial A}{\\partial v}&amp;=-\\frac{V\\left[HA\\right]_0}{(V+v)^2}\\\\ \\frac{\\partial B}{\\partial v}&amp;=\\frac{V\\left[B\\right]_0}{(V+v)^2}\\\\ \\frac{\\partial f_{1,1}}{\\partial x}&amp;=4x^3+3(a+b'+B)x^2+2(ab'+aB-w-Aa)x-(aw+b'w+Aab') \\end{aligned}\\] 2가 산-1가 염기 위에서 얻은 방정식을 가져와보면 아래와 같다. \\[\\begin{aligned} &amp;x^5+(a+b'+B)x^4+(aa'+ab'+aB-w-Aa)x^3\\\\ &amp;+(aa'b'+aa'B-aw-b'w-Aab'-Aaa')x^2\\\\ &amp;-(aa'w+ab'w+Aaa'b')x-aa'b'w=0 \\end{aligned}\\] 위 방정식을 f2,1=0이라고 나타내면 기울기는 아래와 같다. \\[\\begin{aligned} \\frac{dpH}{dv}&amp;=\\frac{d(-\\log_{10}{x})}{dv}=\\frac{1}{x\\ln{10}}\\frac{\\frac{\\partial f_{2,1}}{\\partial v}}{\\frac{\\partial f_{2,1}}{\\partial x}}\\\\ \\frac{\\partial f_{2,1}}{\\partial v}&amp;=\\frac{\\partial A}{\\partial v}(-ax^3-ab'x^2-aa'x^2-aa'b'x)+\\frac{\\partial B}{\\partial v}(x^4+ax^3+aa'x^2)\\\\ \\frac{\\partial A}{\\partial v}&amp;=-\\frac{V\\left[HA\\right]_0}{(V+v)^2}\\\\ \\frac{\\partial B}{\\partial v}&amp;=\\frac{V\\left[B\\right]_0}{(V+v)^2}\\\\ \\frac{\\partial f_{2,1}}{\\partial x}&amp;=5x^4+4(a+b'+B)x^3+3(aa'+ab'+aB-w-Aa)x^2\\\\ &amp;+2(aa'b'+aa'B-aw-b'w-Aab'-Aaa')x\\\\ &amp;-(aa'w+ab'w+Aaa'b') \\end{aligned}\\] 3가 산-1가 염기 위에서 얻은 방정식을 가져와보면 아래와 같다. \\[\\begin{aligned} &amp;x^6+(a+b'+B)x^5+(aa'+ab'+aB-w-aA)x^4\\\\ &amp;+(aa'b'+aa'a''+aa'B-aw-b'w-aAb'-2aa'A)x^3\\\\ &amp;+(aa'a''b'+aa'a''B-aa'w-ab'w-2aa'Ab'-3aa'a''A)x^2\\\\ &amp;-(aa'a''w+aa'b'w+3aa'a''Ab')x-aa'a''b'w=0 \\end{aligned}\\] 위 방정식을 f3,1=0이라고 나타내면 기울기는 아래와 같다. \\[\\begin{aligned} \\frac{dpH}{dv}&amp;=\\frac{d(-\\log_{10}{x})}{dv}=\\frac{1}{x\\ln{10}}\\frac{\\frac{\\partial f_{3,1}}{\\partial v}}{\\frac{\\partial f_{3,1}}{\\partial x}}\\\\ \\frac{\\partial f_{3,1}}{\\partial v}&amp;=\\frac{\\partial A}{\\partial v}(-ax^4-ab'x^3-2aa'x^3-2aa'b'x^2-3aa'a''x^2-3aa'a''b'x)\\\\ &amp;+\\frac{\\partial B}{\\partial v}(x^5+ax^4+aa'x^3+aa'a''x^2)\\\\ \\frac{\\partial A}{\\partial v}&amp;=-\\frac{V\\left[HA\\right]_0}{(V+v)^2}\\\\ \\frac{\\partial B}{\\partial v}&amp;=\\frac{V\\left[B\\right]_0}{(V+v)^2}\\\\ \\frac{\\partial f_{3,1}}{\\partial x}&amp;=6x^5+5(a+b'+B)x^4+4(aa'+ab'+aB-w-aA)x^3\\\\ &amp;+3(aa'b'+aa'a''+aa'B-aw-b'w-aAb'-2aa'A)x^2\\\\ &amp;+2(aa'a''b'+aa'a''B-aa'w-ab'w-2aa'Ab'-3aa'a''A)x\\\\ &amp;-(aa'a''w+aa'b'w+3aa'a''Ab') \\end{aligned}\\]"
					}

					
				
			
		
			
				
					,
					

					"ko-2016-titration": {
						"id": "ko-2016-titration",
						"title": "산-염기 적정 시뮬레이션",
						"category": "",
						"url": " /ko/2016/titration",
						"content": "계기 고등학교 2학년 때 일반화학 II 과목을 수강하였는데, 산-염기 파트의 적정 실험에 대해 공부하던 중에 적정 그래프에 대해 궁금한 점이 생겼다. 강산-강염기, 강산-약염기, 약산-강염기, 약산-약염기 조합에 따른 그래프의 모양이 제각각이었는데, 여기에 규칙성이 있을까에 대한 의문이었다. 또한 다양성자산인 경우에도 그래프의 모양이 다양하게 나와서 이게 서로 연관이 있는가 또한 궁금했다. 일반화학 수준에서 적정 실험을 기술할 때에는 중화점(또는 당량점)과 반당량점에 대한 정보만 계산할 뿐이다. 좌표평면 위에서의 그래프로서의 적정 곡선에 대한 정보는 가르치지 않았기 때문에 상기한 규칙성에 대해 탐구할 방법이 마땅치 않았다. 하지만 이 파트에는 반당량점과 당량점에서의 pH를 계산할 수 있는 식이 존재했다. 바로 Henderson-Hasselbalch 식과 화학식의 평형식이었다. 이를 사용하면 적정 시 투입한 시약의 약에 따른 pH의 값을 꽤 정확하게 구할 수 있다는 생각이 들었다. 1차 (2016.10 ~ 2016.12) 다양성자산은 식을 세우기도 어렵고, 화학평형식으로 이를 구하려면 변수가 여러 개 필요했기 때문에 이 기간에는 1가 산과 1가 염기 사이의 반응만 다루었다. 언어 고등학교 2학년 1학기 때 객체지향프로그래밍 과목을 수강하여 Java에 대한 이론을 어느 정도 공부한 상태였고, 당시 마인크래프트를 즐겨하고 간단한 플러그인도 개발할 수 있었다. 또한 아주 간단한 게임을 개발하기 위해 Java의 GUI 라이브러리인 Swing에 대해서도 일부 찾아보고 있는 상태였다. 그래서 Java를 사용하여 개발하기로 했다. 이론 산성 용액을 염기성 용액으로 적정할 때의 pH 산성 물질에 대한 Henderson-Hasselbalch 식은 아래와 같다. \\[pH=pK_a+\\log{\\frac{\\left[A^-\\right]}{\\left[HA\\right]}}\\] 이제 산 HA에 염기 BOH를 첨가하여 적정하는 상황을 가정한다. 그러면 화학식은 아래와 같이 쓸 수 있다. \\[HA+BOH\\rightarrow H_2O+A^-+B^+,K=\\frac{\\left[A^-\\right]}{\\left[HA\\right]}\\frac{\\left[B^+\\right]}{\\left[BOH\\right]}=\\frac{K_aK_b}{K_w}\\] 산 HA는 농도 Ma에 VamL, 염기 BOH는 농도 Mb에 VbmL가 존재한다고 생각하면 이를 섞었을 때 농도값을 보정해야 한다. 산은 $M’_a=M_a\\times\\frac{V_a}{V_a+V_b}$, 염기는 $M’_b=M_b\\times\\frac{V_b}{V_a+V_b}$의 농도를 가지게 된다. 이제 이 농도를 이용하여 반응의 정도를 계산한다. 반응한 단위부피 당 HA의 몰 수를 $x$로 놓으면 아래와 같이 식을 쓸 수 있다. \\[Q=\\frac{\\left[A^-\\right]\\left[B^+\\right]}{\\left[HA\\right]\\left[BOH\\right]}=\\frac{x^2}{(M'_a-x)(M'_b-x)}\\] 위의 반응지수 값이 평형상수 값과 같아야 하므로 방정식을 아래와 같이 쓸 수 있다. \\[Q=\\frac{x^2}{(M'_a-x)(M'_b-x)}=K\\\\ x^2=K(M'_a-x)(M'_b-x)\\\\ (K-1)x^2-K(M'_a+M'_b)x+KM'_aM'_b=0\\] 위 방정식에서 $x$ 자리에 0과 $M’_a$를 각각 넣어보면 전자는 $KM’_aM’_b$로 양수, 후자는 $-{M’_a}^{2}$로 음수가 나오므로 반드시 (0, $M’_a$) 사이에 해가 단 하나 존재한다1 2. 그 유일한 해 x를 사용하여 pH를 구할 것이다. pH는 위에서 언급한 Henderson-Hasselbalch 식을 사용해서 구한다. \\[pH=pK_a+\\log{\\frac{\\left[A^-\\right]}{\\left[HA\\right]}}=pK_a+\\log{\\frac{x}{M'_a-x}}\\] 염기성 용액을 산성 용액으로 적정할 때의 pH 이 경우는 위의 경우를 조금 변형시키면 같은 방식으로 계산이 가능하다. 이것은 pOH의 개념을 도입하면 쉽게 설명이 가능하다. \\[pOH=-\\log{\\left[OH^-\\right]}\\\\ \\begin{aligned} pH+pOH&amp;=-(\\log{\\left[H^+\\right]}+\\log{\\left[OH^-\\right]})\\\\ &amp;=-\\log{\\left[H^+\\right]\\left[OH^-\\right]}\\\\ &amp;=-\\log{K_w}\\\\ &amp;=pK_w\\simeq14(298K) \\end{aligned}\\] 이제 위와 마찬가지로 구하되, 염기성 용액에 대한 Henderson-Hasselbalch 식을 사용하고, pH 대신 pOH를 구한 후 이 값을 14에서 빼주면 pH를 구할 수 있다. 식으로 표현하면 아래와 같다. \\[pOH=pK_b+\\log{\\frac{\\left[B^+\\right]}{\\left[BOH\\right]}}=pK_b+\\log{\\frac{y}{M'_b-y}}\\\\ pH=14-pOH=14-(-\\log_{10}{y})\\] 개발 pH를 그래프로 옮기기 적정 그래프는 보통 x축이 넣은 적정 시약의 양, y축이 pH인 좌표평면 위에 그린다. 이를 위해 그림판(!)을 사용하여 그럴듯한 좌표평면을 만들었다. 당시 사용한 좌표평면은 아래와 같다. 각 그리드는 50×40 픽셀 크기를 가지고 있으며, 좌표평면의 총 크기는 1000×560 픽셀이다. 그리고 x축의 끝은 당량점의 2배가 되는 지점을 잡았다. 어차피 이미지는 픽셀로 렌더링되기에 계산하기 편하게 하자는 생각에 이렇게 만들었다. 즉, 넣은 부피는 당량점에 해당하는 부피의 1 500 단위로 하여 각 부피마다 구한 pH를 0.025단위로 반올림하여 y좌표를 정한 후 해당 픽셀에 점을 찍으면 자연스럽게 그래프처럼 보일 것이라 예상하여 그 방법을 택했다. 내용 추가 예정3 2차 (2017.03 ~ 2017.06) 고등학교 3학년에 올라와서 졸업논문을 쓸 시기가 되어 이것저것 연구 주제를 찾아보던 중 이것을 조금 더 발전시킨 후 논문으로 쓰면 좋겠다는 생각이 들었다. 그래서 단양성자산만을 계산하는 이 프로그램에서 다양성자산(황산, 인산 등)에 대한 부분까지 지원하기로 했다. 앞의 1차 개발에서 다양성자산의 경우 변수가 여러 개라 방정식을 세우기 힘든 점을 돌파하는 것이 목표가 되었다. 다양한 산에 대한 pH 도출 적정에 대한 분석화학적 접근 앞의 1차 개발에서는 적정 반응에 대하여 화학평형식만으로 계산을 진행했는데, 다양성자산에 대해서는 쉽게 구할 수 없었다. 그래서 이 반응에 대해 다르게 접근하는 방법이 있는지에 대하여 구글링을 해보다가 분석화학(Analytical Chemistry)의 관점으로 접근하는 방법이 존재했다. 그래서 학교 도서관에서 단 두 권 존재하는 분석화학 책을 찾아 관련 식을 이것저것 찾아보았다(어떤 책이었는지는 기억이 나지 않는다). 그 내용은 아래와 같다. 관련된 반응식을 모두 적는다. 양전하의 전하 양과 음전하의 전하 양이 같은지 비교한다(전하 균형을 맞춘다). 특정 원소에 대하여 반응 전의 양과 반응 후의 양을 맞춘다(질량 균형을 맞춘다). 각 반응의 평형 상수를 적고 이를 푼다. 이 방식을 사용하여 식을 세우고 이를 방정식으로 만들면 다양성자산에 대해서도 원하는 값을 어렵지 않게 얻을 수 있을 것이라 생각했다. 그 때 풀었던 내용은 아래와 같다. 1가 산-1가 염기 먼저 반응식을 적어보면 아래와 같다. \\[HA\\rightarrow H^++A^-\\\\ B+H_2O\\rightarrow BH^++OH^-\\\\ H^++OH^-\\rightarrow H_2O\\] 반응식에 연관된 이온들을 모두 찾은 후 전하의 균형을 맞추고 A와 B에 대하여 질량 균형을 맞춰보면 아래와 같다. \\[\\left[H^+\\right]+\\left[BH^+\\right]=\\left[A^-\\right]+\\left[OH^-\\right]\\\\ \\left[HA\\right]_0=\\left[HA\\right]+\\left[A^-\\right]\\\\ \\left[B\\right]_0=\\left[B\\right]+\\left[BH^+\\right]\\] 그리고 위에서 적은 반응식에 대하여 평형 상수를 구해보면 아래와 같다. \\[K_1=K_a=\\frac{\\left[H^+\\right]\\left[A^-\\right]}{\\left[HA\\right]}\\\\ K_2=K_b=\\frac{\\left[BH^+\\right]\\left[OH^-\\right]}{\\left[B\\right]}\\\\ K_3=K_w\\] 이 상태로 식을 정리하면 매우 복잡하고 길기 때문에 복잡한 기호를 다른 기호로 치환한다. 여기서 V는 적정하려는 시약의 부피, v는 첨가한 표준 용액의 부피이다. \\[\\begin{aligned} K_a&amp;\\rightarrow&amp;a\\\\ K_b&amp;\\rightarrow&amp;b\\\\ K_w&amp;\\rightarrow&amp;w\\\\ \\left[HA\\right]_0\\cdot\\frac{V}{V+v}&amp;\\rightarrow&amp;A\\\\ \\left[B\\right]_0\\cdot\\frac{v}{V+v}&amp;\\rightarrow&amp;B\\\\ \\left[H^+\\right]&amp;\\rightarrow&amp;x\\\\ \\left[OH^-\\right]&amp;\\rightarrow&amp;y&amp;=w x \\end{aligned}\\] $b’=\\frac{w}{b}$4로 잡은 후 위 식을 정리하여 $x$에 대한 방정식을 세우면 아래와 같이 된다. 자세한 과정은 여기를 참고하면 된다. \\[x^4+(a+B+b')x^3+(ab'+aB-Aa-w)x^2\\\\ -(Aab'+aw+wb')x-awb'=0\\] 2가 산-1가 염기 반응식은 아래와 같다. \\[H_2A\\rightarrow H^++HA^-\\\\ HA^-\\rightarrow H^++A^{2-}\\\\ B+H_2O\\rightarrow BH^++OH^-\\\\ H^++OH^-\\rightarrow H_2O\\] 전하 균형과 질량 균형을 맞춰보면 아래와 같다. \\[\\left[H^+\\right]+\\left[BH^+\\right]=\\left[HA^-\\right]+2\\left[A^{2-}\\right]+\\left[OH^-\\right]\\\\ \\left[H_2A\\right]_0=\\left[H_2A\\right]+\\left[HA^-\\right]+\\left[A^{2-}\\right]\\\\ \\left[B\\right]_0=\\left[B\\right]+\\left[BH^+\\right]\\] 각 반응식에 대한 평형 상수는 아래와 같다. \\[K_1=K_{a1}=\\frac{\\left[H^+\\right]\\left[HA^-\\right]}{\\left[H_2A\\right]}\\\\ K_2=K_{a2}=\\frac{\\left[H^+\\right]\\left[A^{2-}\\right]}{\\left[HA^-\\right]}\\\\ K_3=K_b=\\frac{\\left[BH^+\\right]\\left[OH^-\\right]}{\\left[B\\right]}\\\\ K_4=K_w\\] 1가 산-1가 염기와 마찬가지로 다른 기호로 치환한다. 위와 마찬가지로 V는 적정하려는 시약의 부피, v는 첨가한 표준 용액의 부피이다. \\[\\begin{aligned} K_{a1}&amp;\\rightarrow&amp;a\\\\ K_{a2}&amp;\\rightarrow&amp;a'\\\\ K_b&amp;\\rightarrow&amp;b\\\\ K_w&amp;\\rightarrow&amp;w\\\\ \\left[H_2A\\right]_0\\cdot\\frac{V}{V+v}&amp;\\rightarrow&amp;A\\\\ \\left[B\\right]_0\\cdot\\frac{v}{V+v}&amp;\\rightarrow&amp;B\\\\ \\left[H^+\\right]&amp;\\rightarrow&amp;x\\\\ \\left[OH^-\\right]&amp;\\rightarrow&amp;y&amp;=w x \\end{aligned}\\] $b’=\\frac{w}{b}$4로 잡은 후 위 식을 정리하여 $x$에 대한 방정식을 세우면 아래와 같이 된다. 자세한 과정은 여기를 참고하면 된다. \\[x^5+(a+B+b')x^4+(aa'+ab'+aB-Aa-w)x^3\\\\ +(aa'b'+aa'B-Aab'-aw-wb'-2aa'A)x^2\\\\ -(awb'+aa'w+2aa'Ab')x-aa'wb'=0\\] 3가 산-1가 염기 반응식은 아래와 같다. \\[H_3A\\rightarrow H^++H_2A^-\\\\ H_2A^-\\rightarrow H^++HA^{2-}\\\\ HA^{2-}\\rightarrow H^++A^{3-}\\\\ B+H_2O\\rightarrow BH^++OH^-\\\\ H^++OH^-\\rightarrow H_2O\\] 전하 균형과 질량 균형을 맞춰보면 아래와 같다. \\[\\left[H^+\\right]+\\left[BH^+\\right]=\\left[H_2A^-\\right]+2\\left[HA^{2-}\\right]+3\\left[A^{3-}\\right]+\\left[OH^-\\right]\\\\ \\left[H_3A\\right]_0=\\left[H_3A\\right]+\\left[H_2A^-\\right]+\\left[HA^{2-}\\right]+\\left[A^{3-}\\right]\\\\ \\left[B\\right]_0=\\left[B\\right]+\\left[BH^+\\right]\\] 각 반응식에 대한 평형 상수는 아래와 같다. \\[K_1=K_{a1}=\\frac{\\left[H^+\\right]\\left[H_2A^-\\right]}{\\left[H_3A\\right]}\\\\ K_2=K_{a2}=\\frac{\\left[H^+\\right]\\left[HA^{2-}\\right]}{\\left[H_2A^-\\right]}\\\\ K_3=K_{a3}=\\frac{\\left[H^+\\right]\\left[A^{3-}\\right]}{\\left[HA^{2-}\\right]}\\\\ K_4=K_b=\\frac{\\left[BH^+\\right]\\left[OH^-\\right]}{\\left[B\\right]}\\\\ K_5=K_w\\] 편의를 위해 상수를 다른 기호로 치환한다. 위와 마찬가지로 V는 적정하려는 시약의 부피, v는 첨가한 표준 용액의 부피이다. \\[\\begin{aligned} K_{a1}&amp;\\rightarrow&amp;a\\\\ K_{a2}&amp;\\rightarrow&amp;a'\\\\ K_{a3}&amp;\\rightarrow&amp;a''\\\\ K_b&amp;\\rightarrow&amp;b\\\\ K_w&amp;\\rightarrow&amp;w\\\\ \\left[H_3A\\right]_0\\cdot\\frac{V}{V+v}&amp;\\rightarrow&amp;A\\\\ \\left[B\\right]_0\\cdot\\frac{v}{V+v}&amp;\\rightarrow&amp;B\\\\ \\left[H^+\\right]&amp;\\rightarrow&amp;x\\\\ \\left[OH^-\\right]&amp;\\rightarrow&amp;y&amp;=w x \\end{aligned}\\] $b’=\\frac{w}{b}$4로 잡은 후 위 식을 정리하여 $x$에 대한 방정식을 세우면 아래와 같이 된다. 자세한 과정은 여기를 참고하면 된다. \\[x^6+(a+B+b')x^5+(ab'+aB-w-aA)x^4\\\\ +(aa'b'+aa'a''+aa'B-aw-wb'-aAb'-2aa'A)x^3\\\\ +(aa'a''b'+aa'a''B-aa'w-awb'-2aa'Ab'-3aa'a''A)x^2\\\\ -(aa'a''w+aa'wb'+3aa'a''Ab')x-aa'a''wb'=0\\] 고차방정식의 해 구하기 뉴턴의 방법(Newton’s Method, Newton-Raphson Method) 실계수 다항방정식은 5차 이상에 대하여 일반해를 구할 수 없다고 알려져있다. 그런데 1차 산-1차 염기 적정 과정을 제외한 나머지 과정은 5차 이상의 방정식을 풀어야 한다. 하지만 그래프를 정확히 그릴 필요는 없고 일정 정확도 이상의 근사해만 알아도 픽셀 단위로는 정확한 그래프를 그릴 수 있다. 이 때 방정식의 해를 근사할 수 있는 방법으로 뉴턴의 방법을 채택했다. 그 과정은 아래와 같다. \\[x_{n+1}=x_n-\\frac{f(x_n)}{f'(x_n)}\\] 이 과정을 반복하여 ${x_n}$이 수렴한다면 그 수렴값을 방정식의 근사해로 잡는 것이다. 다만 이 과정을 시작하는 값에 따라 수렴하지 않을 수 있고, 컴퓨터의 실수 정확도 문제로 예상과 다른 결과가 나올 수 있다. 따라서 시작하는 값을 수렴할 확률이 더욱 높게 잡는 방법에 대해 생각해보았다. 뉴턴의 방법 개량 중간값 정리에 따라 다항함수 f에 대하여 음수인 점과 양수인 점을 잡으면 두 점 사이에 항상 근이 존재한다. 그런데 그 두 점이 하필 도함수 값이 0이고 두 점 사이의 점에서는 부호가 일정하다면 해가 유일하게 존재한다.5 이제 도함수 값이 0이 되는 점을 찾으면 된다. 만약 n차방정식의 해를 구하려고 한다면 (n-1)차방정식의 해를 구한 후 근사법을 사용해서 원래 방정식의 해를 구할 수 있는 것이다. 이를 재귀적으로 시행하다보면 일차방정식의 해를 구하는 과정까지 온다. 1차 함수는 $x=-\\frac{b}{a}$를 사용하여 정확한 해를 구할 수 있으므로 결국 n차 방정식의 해를 구할 수 있게 된다. 이 아이디어에서 착안하여 프로그램에 사용한 알고리즘은 아래와 같다. 일차방정식이라면 정확한 해를 반환한다. 주어진 계수를 사용하여 도함수를 구한다. 도함수의 해를 구하는 함수를 호출하여 해를 얻는다.(재귀) 각 해에 대하여 함숫값을 얻는다. 각 해에 대하여 함숫값이 0이라면 해집합에 추가한다. 가장 왼쪽의 해는 1을 뺀 값에서 근사를 시작하고 가장 오른쪽의 해는 1을 더한 값에서 근사를 시작한다. 인접한 해끼리 함숫값을 비교하여 부호가 다르면 두 해의 중간 위치에서 근사를 시작한다. 위의 두 근사 과정에 대하여 범위를 벗어나면 근사를 종료하고, 만약 수렴한 값이 존재하면 해집합에 추가한다. 해집합을 반환한다. 이를 그림으로 표현하면 아래와 같다. 이 방법으로 진행하면 높은 확률로 수렴한 값을 찾을 수 있게 된다. 정량적으로 어느 정도 개선되었는지는 알 수 없으나 이 방법을 채택한 후 프로그램을 실행할 때 무한 루프나 예외가 발생하는 횟수가 눈에 띄게 줄었다. 그래프의 기울기 그래프를 그리고 보니 미적분I 수업 당시 선생님께서 “미분은 그래프의 개형을 판단하기 위한 연산이다”라고 말씀하신 것이 떠올라 이 적정 그래프 또한 기울기를 구할 수 있을까에 대하여 고민하기 시작했다. 앞의 방정식 유도에서 사용한 분석화학 전공 책을 뒤져봤지만 자세한 내용을 얻을 수 없어 구글링을 시도했다. 찾아보다가 StackExchange에서 편미분을 사용하여 할 수 있다는 내용을 보았다. 그래서 아래와 같은 방식으로 식을 유도했다. 방정식을 $f(x,v)=0$꼴로 쓴다면, \\[f(x,v)=0\\\\ 0=df=\\frac{\\partial f}{\\partial x}dx+\\frac{\\partial f}{\\partial v}dv\\\\ \\frac{dx}{dv}=-\\frac{\\frac{\\partial f}{\\partial v}}{\\frac{\\partial f}{\\partial x}}\\\\ \\begin{aligned} \\therefore\\frac{d(pH)}{dv}&amp;=\\frac{d(-\\log{x})}{dv}\\\\ &amp;=\\frac{-\\frac{1}{x\\ln{10}}dx}{dv}\\\\ &amp;=-\\frac{1}{x\\ln{10}}\\frac{dx}{dv}\\\\ &amp;=\\frac{1}{x\\ln{10}}\\frac{\\frac{\\partial f}{\\partial v}}{\\frac{\\partial f}{\\partial x}} \\end{aligned}\\] 의 식으로 그래프의 기울기를 구할 수 있는 것이다. 경우에 따라 이 식을 전개한 식은 방정식 유도 과정에서 찾아볼 수 있다. 개발 내용 추가 예정3 (해가 하나 이상 존재함) 직전 학기에 학습했던 미적분학 I에서 나온 중간값 정리를 사용하면 주어진 범위에서 해가 하나 이상 존재함을 보일 수 있다. &#8617; (해가 2개 존재할 수 없음) 이차방정식은 실수 전체 범위에서 실근을 최대 2개 가지는데, (0, $M’_a$)에서 해가 하나 이상 존재함을 보였으므로 이 범위에서는 해가 하나이거나 2개이다. ① 해당 범위에서 중근을 가진다고 가정하자. 그러면 실수 전체 범위의 x에 대해 $f(x)\\le 0$ 또는 $f(x)\\ge 0$을 만족한다. 그런데 주어진 범위의 양 끝 값에 대한 함수값의 부호가 다르므로 중근일 수 없다. ② 해당 범위에서 서로 다른 두 실근이 존재한다고 가정하자. 그러면 중간값 정리에 의해 두 실근 사이의 어떤 실수 y가 존재하여 $f(0)f(y)&lt;0$, $f(y)f(M’_a)&lt;0$를 만족해야 한다. 그런데 두 식을 곱해보면 $f(0)f(y)^2f(M’_a)&gt;0$을 만족해야 하고, $f(y)^2$는 항상 양수이므로 $f(0)f(M’_a)&gt;0$, 즉, 범위의 양 끝 값에 대한 함수값의 부호가 같아야 한다. 그런데 주어진 범위의 양 끝 값에 대한 함수값의 부호가 다르므로 서로 다른 두 실근을 가질 수 없다. 따라서 위의 이차방정식은 (0, $M’_a$)의 범위에서 근을 단 하나 가진다. &#8617; 현재 시점에는 이 프로젝트 때 사용했던 컴퓨터 이후로 2번 바뀐 상태라 그 때 사용하던 파일을 찾는 데에 시간이 좀 걸립니다… &#8617; &#8617;2 식의 의미 상 B+의 이온화 상수다. &#8617; &#8617;2 &#8617;3 연속함수 f와 폐구간 I에서 양 끝점을 제외한 구간의 모든 점에 대해 도함수 f’의 부호가 일정하다면 그 정의에 따라 I에서 f는 단조롭다. 일반성을 잃지 않고 함수가 증가한다고 가정하면, 그 정의에 따라 I의 임의의 두 점 (a, f(a)), (b, f(b))를 잡았을 때 a&gt;b라면 f(a)&gt;f(b)를 만족한다. 이제 양 끝점의 함숫값의 부호가 다르다고 가정하자. 함수가 증가한다고 가정했으므로 왼쪽 끝점은 함숫값이 음수, 오른쪽 끝점은 양수가 된다. 이제 I의 두 점 (x, 0)와 (y, 0), x≠y가 존재한다고 가정해보겠다. 일반성을 잃지 않고 x&gt;y라고 가정하겠다. 그러면 f는 증가함수이므로 f(x)&gt;f(y)여야 한다. 그런데 가정에서 f(x)=0=f(y)라고 하였으므로, 모순이 된다. 즉, 함수 f에서 근은 많아야 하나 존재할 수 있다. &#8617;"
					}

					
				
			
		
			
				
					,
					

					"ko-2019-plcomp": {
						"id": "ko-2019-plcomp",
						"title": "프로그래밍언어 최종 과제",
						"category": "",
						"url": " /ko/2019/plcomp",
						"content": "개요 이 문서는 2019년 1학기 프로그래밍언어 과목의 최종 과제의 내용을 정리한 문서이다. Github에 이 과제를 위한 Repository가 있고 관련 내용도 README.md에 정리되어있지만 내용을 복습하고 코드에 대한 설명도 간단히 첨부할 겸 새로 작성한다. 이 과제에서 요구하는 바는 아래와 같다. 코드를 토큰으로 변환하고 Symbol Table 대략적으로 작성(Scanning) 코드가 주어진 문법에 맞는 코드인지 판단하고 Symbol Table 구성(Parsing) 코드를 주어진 유사-어셈블리 문법으로 변환(Code Generating) 과제 내용 여기에서 원문을 볼 수 있다. 아래는 이 파일의 내용을 정리한 것이다. Scanner: 후술할 문법을 올바른 형태의 Transition Table로 변환한 후 DFA 또는 NFA를 사용하여 Scanner를 개발하시오. Parser: Scanner를 통해 생성한 Token이 문법과 맞는지 확인하고 PDA를 사용해서 Parser를 구현하시오. Code Generator: 입력 코드를 후술할 Pseudo Code의 문법에 맞게 변환하시오. Input Grammar prog ::= word \"(\" \")\" block ; block ::= \"{\" slist \"}\" | ; slist ::= slist stat | stat ; stat ::= IF \"(\" cond \")\" THEN block ELSE block | WHILE \"(\" cond \")\" block | word \"=\" expr \";\" | ; cond ::= expr \"&gt;\" expr | expr \"&lt;\" expr ; expr ::= fact | expr \"+\" fact ; fact ::= num | word ; word ::= ([a-z] | [A-Z])* ; num ::= [0-9]* Pseudocode Instructions LD Reg#1, addr(or num) | Reg#1에 변수 또는 값을 로드 ST Reg#1, addr | Reg#1의 값을 변수에 저장 ADD Reg#1, Reg#2, Reg#3 | Reg#1 = Reg#2 + Reg#3 LT Reg#1, Reg#2, Reg#3 | Reg#2 &lt; Reg#3이면 1을, 아니면 0을 Reg#1에 저장 JUMPF Reg#1, label | Reg#1이 0이면 label로 점프 JUMPT Reg#1, label | Reg#1이 0이 아니면 label로 점프 JUMP label | label로 점프 MV Reg#1, Reg#2 | Reg#1의 값을 Reg#2에 설정 추가 사항 코드와 Symbol Table을 같이 출력 함수는 BEGIN 이름으로 시작하고 END 이름으로 종료 사용하는 레지스터의 개수를 최소화, 사용한 레지스터의 개수 출력 주어진 문법을 변경해야 할 때에는 어떻게, 왜 변경했는지 서술 관련 이론 Scanner Scanner의 기능은 입력받은 문자열을 Parser가 인식할 수 있는 단위인 토큰 단위로 구분하는 것이다. 이 토큰의 형식은 보통 정규 표현식1으로 정해지며, 주어진 입력이 만족하는 정규 표현식이 존재하지 않는 경우 작동을 중지하고 에러를 출력할 수 있다. 또한 Scanner는 추가적으로 Symbol Table의 기초적인 부분을 구성한다. 토큰을 만드는 과정에서 등장한 keyword나 수가 아닌 단어(ex. [A-Za-z_][A-Za-z0-9_]*)는 이 프로그램에 등장한다고 체크를 해놓는다. Scanner의 구현은 Finite Automata를 사용한다. 그 중에서도 구상은 NFA가 더 쉽기 때문에 NFA의 형태로 구상한다. 하지만 이를 직접 구현하는 것은 난이도가 있는 것인지 구상한 NFA를 DFA로 변환한 후 이 DFA를 구현한다.2 DFA DFA는 Deterministic Finite Automaton의 약자이다. DFA는 (Q,Σ,δ,q0,F)와 같은 집합으로 나타낼 수 있다. Q: 가능한 모든 상태의 집합 Σ: 입력값으로 들어올 수 있는 문자의 집합 δ: 현재 상태와 입력 문자에 대해 다음 상태를 나타내는 전이 함수 (δ: Q×Σ→Q) 3 q0: 오토마타가 동작을 시작할 때의 초기 상태 (q0∈Q) F: 오토마타가 입력이 끝났을 때 Accept로 인식할 Accept 상태의 집합 (F⊂Q) 이제 길이가 n인 어떤 문자열 w∈Σ*가 있다고 하자. 이 때의 작동 방식은 w를 구성하는 문자 순서대로 상태를 전이시킨다. 그리고 w의 문자를 모두 입력받은 후의 상태가 F에 포함되는지 확인하고 결과값을 출력한다. 이를 의사코드로 써보면 아래와 같다. q[0] = q_0 for i in range(0, n): q[i+1] = δ(q[i], w[i]) print(q[n] in F) NFA NFA는 Non-deterministic Finite Automaton의 약자이다. NFA는 (Q,Σ,Δ,q0,F)와 같은 집합으로 나타낼 수 있다. Q: 가능한 모든 상태의 집합 Σ: 입력값으로 들어올 수 있는 문자의 집합 Δ: 현재 상태와 입력 문자에 대해 다음 상태의 집합을 나타내는 전이 함수 (Δ: Q×Σ→P(Q)) q0: 오토마타가 동작을 시작할 떄의 초기 상태 (q0∈Q) F: 오토마타가 입력이 끝났을 때 Accept로 인식할 Accept 상태의 집합 (F⊂Q) 위의 DFA와 다른 점은 전이 함수의 함수값의 형태가 다르다는 것이다. DFA에서는 상태와 문자를 입력값으로 하여 상태 하나를 반환하는 전이 함수 δ였지만 NFA에서는 상태의 집합을 반환한다. 이를 고려하여 동작 메커니즘을 생각해보면 아래와 같다. q[0] = set(q_0) for i in range(0, n): q[i+1] = set() for x in q[i]: q[i+1] = union(q[i+1], Δ(x, w[i])) print(!(q[n].intersect(F).empty())) 과제에 맞는 작동 방식 구상 FA의 전이 함수는 완전 함수일 필요가 없다. 이를 사용하여 토큰의 조건을 만족하는 경우에 대해서만 전이 함수의 함수값을 정의하고 이외의 경우에 대해서는 정의하지 않아 에러를 유발하는 방식을 사용할 것이다. 에러가 발생하면 지금까지 입력받은 문자를 기반으로 토큰을 생성한 후, 처음 위치로 돌아가 해당 문자(공백 문자는 그 다음 문자)를 다시 전이 함수에 대입하여 과정을 반복하는 방법을 사용하면 된다. 여기에 Symbol Table도 여기서 일부 구성한다. 대입(=) operator가 나오면 바로 앞의 토큰을 확인하여 토큰의 값을 Symbol Table에 등장하는 변수의 이름으로 추가한다.4 Parser Parser는 기본적으로 Scanner로부터 생성된 토큰을 입력받아 코드가 문법에 맞는지 체크하는 기능을 한다. 문법은 보통 과제에서 주어지는 것처럼 Production rule의 형태로 주어진다. 보통 Parser는 PDA(Pushdown Automaton)으로 구현하는데, 이 경우 Production rule을 그대로 사용할 수는 없기 때문에 주어진 문법을 오토마타의 종류에 맞는 transition table로 변환한다. 비교적 간단한 문법의 경우 SLR(1)이나 LR(0)을 사용한다. LR Parser는 Shift와 Reduce라는 동작을 통해 Stack을 조작하여 문자열이 문법에 맞는지 판단한다. 어떤 상황에서 어떤 동작을 사용할지는 LR Parser의 파생형인 SLR, CLR, LALR마다 조금씩 다르다. 과제에서 주어진 문법의 경우 간단한 편이기 때문에 SLR(1)로 구현이 가능하므로 SLR(1)에서의 transition table을 구성하는 방법에 대해 서술한다. Transition Table의 구성(SLR(1)) 간단한 문법이 아래와 같이 주어져있다고 가정하자. E → E \"+\" T E → T T → T \"*\" F T → F F → n 이 문법은 Context-free grammar에 속하며, G=(V,Σ,R,S) 형식으로 정의할 수 있다. 그 의미와 위 문법에서의 예시는 아래와 같다. V: non-terminal 또는 variable의 집합이다. 이 집합에 속하는 원소는 대문자 알파벳을 사용하여 나타낸다. 위 문법 기준으로는 {E, T, F}이다. Σ: terminal의 집합이다. 이 집합에 속하는 원소는 소문자 알파벳으로 나타내거나 문자 그 자체로 나타내기도 한다. 위 문법 기준으로는 {\"+\", \"*\", n}이다. R: 위의 production rule과 같이 하나의 non-terminal이 어떤 terminal 또는 non-terminal로 전개될 수 있는지에 대한 관계를 모아놓은 함수이다. 위 production rule 자체가 함수라고 볼 수 있다. S: 전개를 시작할 non-terminal이다. 반드시 V의 원소여야 한다. 위 문법 기준으로는 E를 사용해도 되지만, 보통은 새로운 non-terminal E’을 만들고 E' → E $의 새로운 문법을 추가해서 사용한다. $는 입력의 끝(EOF)를 의미한다. 위에서 언급한 E' → E $ 문법을 추가한 후 • 기호를 도입한다. 이 기호는 오토마타가 현재 어느 지점을 읽고 있는지를 의미한다. 이 기호를 도입하기 전에 Production rule에 존재하는 ε-transition을 없애고 시작해야 한다. 이 예시의 경우는 ε-transition이 없기 때문에 처리할 것은 없지만 과제의 문법은 처리할 문법이 몇 가지 존재한다. 우선 starting state로 정의한 E’에 대하여 적용한다. E' → •E $ E → •E \"+\" T E → •T T → •T \"*\" F T → •F F → •n 위와 같이 • 기호 바로 뒤에 있는 것이 non-terminal 기호인 경우는 해당 non-terminal을 좌항으로 가지고 있는 문법에 대해서 재귀적으로 적용한다. 이제 위 블럭 전체를 하나의 상태로 정의한다. q0라고 하겠다. 이 상태에서 E, T, F, n을 각각 하나 읽은 상태를 의미하는 상태를 만들어보겠다. E' → E •$ E → E •\"+\" T E → T• T → T •\"*\" F T → F• F → n• 위의 4개의 상태 중 첫 2개의 상태는 terminal인 +와 *를 읽은 이후의 상태를 또 만들 수 있을 것이다. E → E \"+\" •T T → •T \"*\" F T → •F F → •n T → T \"*\" •F F → •n 각 상태를 만들어보니 • 기호가 non-terminal 앞에 가게 되면서 여러 production rule이 상태에 다시 추가되었다. 이러한 방법을 계속 사용하여 가능한 모든 상태를 만들면 transition table 생성에 사용할 다이어그램이 완성된다. 여기서 주의할 점은 상태 전이 시 FA와 다르게 non-terminal도 정의역에 포함된다. 즉, 정의역이 (V∪Σ)*이다. 이를 바탕으로 그림을 그려보면 아래와 같이 될 것이다. 이제 transition table에 사용하기 위해 각 non-terminal(이 문법의 경우는 E, T, F까지 총 3개이다)에 대하여 FOLLOW 집합을 만든다. FOLLOW 집합은 이 non-terminal 바로 다음에 올 수 있는 terminal 문자의 집합이다. 5 Non-terminal FOLLOW E’ {$} E {+}∪FOLLOW(E’)={$, +} T {*}∪FOLLOW(E)={$, +, *} F FOLLOW(T)={$, +, *} 이를 사용하여 transition table을 만드는 것은 아래와 같은 방법으로 진행한다. Table을 하나 만들고, 세로줄에는 상태의 번호, 가로줄에는 terminal과 $(EOF)을 모두 넣고 starting symbol을 제외한 non-terminal을 그 옆에 넣는다. terminal의 항 위에는 Action, non-terminal의 항 위에는 Goto라고 이름을 붙인다. 다이어그램에서 각 상태마다 terminal에 의한 transition은 S(도착 상태 번호)(shift), non-terminal에 의한 transition은 (도착 상태 번호)의 형식으로 추가한다. EOF가 허용된 상태에서 EOF를 입력받는 경우는 Acc 또는 A라고 표시한다. 어떤 상태에서 하나 이상의 문법에 대하여 • 기호가 오른쪽 끝에 가있는 경우 reduce 작업이 필요하다. production rule 형태에서 해당 문법의 번호를 가져와서 R(번호)의 형태로 transition table에 추가한다. 이 때 문법의 좌변에 해당하는 non-terminal의 FOLLOW 집합에 속해있는 terminal의 위치에만 추가한다. 이러한 작업을 거치면 아래와 같이 transition table을 생성할 수 있다. (0) E' → E $ (1) E → E \"+\" T (2) E → T (3) T → T \"*\" F (4) T → F (5) F → n ActionGoto n+*$ETF 0S6187 1S2Acc 2S637 3R1S4R1 4S65 5R3R3R3 6R5R5R5 7R4R4R4 8R2S4R2 Transition Table을 활용한 Parser 구현 위에서 쓰던 예시를 그대로 사용하겠다. Parser를 구현할 때에는 스택(Parsing Stack)과 임시 변수(Lookahead)가 하나 필요하다. 문자열을 처리하면서 어떤 상태로 파싱을 진행하는지 저장하는 용도이다. 이 변수를 사용하면 PDA는 아래와 같이 작동한다. 예시로 n*n+n을 파싱해보겠다. Input Parsing Stack Lookahead Operation n*n+n$ 0 n S6 *n+n$ 0 n 6 * R5(F→n) *n+n$ 0 F 7 * R4(T→F) *n+n$ 0 T 8 * S4 n+n$ 0 T 8 * 4 n S6 +n$ 0 T 8 * 4 n 6 + R5(F→n) +n$ 0 T 8 * 4 F 5 + R3(T→T*F) +n$ 0 T 8 + R2(E→T) +n$ 0 E 1 + S2 n$ 0 E 1 + 2 n S6 $ 0 E 1 + 2 n 6 $ R5(F→n) $ 0 E 1 + 2 F 7 $ R4(T→F) $ 0 E 1 + 2 T 3 $ R1(E→E+T) $ 0 E 1 $ Acc 위 과정을 통해 예시의 문자열은 문법을 만족하는 문자열임을 알 수 있다. 그리고 연산의 종류에 따른 PDA의 작동 방식은 아래와 같이 될 것이다. Shift: lookahead 문자를 stack에 push하고 상태의 번호도 같이 stack에 push한 뒤 Input의 가장 왼쪽 문자를 제거한다. Reduce: (Reduce할 문법의 우변에 있는 terminal과 non-terminal 원소 개수)×2만큼 stack을 pop한다. 그리고 stack의 top의 상태 번호와 좌변의 non-terminal에 해당하는 transition table의 goto 칸을 찾는다. 여기서 나온 상태의 번호를 non-terminal과 함께 stack에 push한다. 개발 과제 조건에서 부득이한 경우 문법을 변경할 수 있고, 그 내용과 이유를 보고서에 기입하도록 되어있다. 그래서 실제 개발에 대한 내용을 작성하기 전에 문법에 관련된 내용부터 작성한다. 문법 변경 주어진 문법을 읽고 이해하는 과정에서 몇 가지 이상한 점을 발견했다. 그 내용은 아래와 같다. block이 ε이 될 수 있다. block이 직접적으로 포함되어있는 prog 입장에서는 word \"(\" \")\"에서 함수를 선언하고 그 뒤로 함수의 내용이 있어야 하는데 block이 ε이면 함수의 내용이 없는 것이다. 즉, 선언만 하고 구현하지 않는 경우이다. 이 문법에 따르면 함수 선언은 프로그램에서 단 한 번 등장하고 함수 호출은 없기 때문에 함수를 구현하지 않고 선언만 하는 것은 의미가 없다. 따라서 block이 ε이 되는 경우를 문법에서 배제했다. word와 num이 ε이 될 수 있다. ε이 된 경우 expr를 살펴보겠다. expr ::= expr \"+\" fact의 부분에서 fact가 ε이 될 수 있으므로 3+++4+와 같은 식도 올바른 코드가 된다. 또한 stat에서도 stat ::= word \"=\" expr \";\"인 문법이 있는데, 여기서 word가 ε라고 하면 =7;도 올바른 코드이다. 하지만 위 두 경우 모두 일반적인 프로그래밍 언어에서는 잘못된 코드이며 Pseudocode Instruction로 구현하는 데에 있어서도 어려움이 있을 것이다. 따라서 word와 num의 와일드카드 *를 +로 대체했다. 위 내용을 적용한 문법은 아래와 같다. prog ::= word \"(\" \")\" block ; block ::= \"{\" slist \"}\" ; slist ::= slist stat | stat ; stat ::= IF \"(\" cond \")\" THEN block ELSE block | WHILE \"(\" cond \")\" block | word \"=\" expr \";\" | ; cond ::= expr \"&gt;\" expr | expr \"&lt;\" expr ; expr ::= fact | expr \"+\" fact ; fact ::= num | word ; word ::= ([a-z] | [A-Z])+ ; num ::= [0-9]+ Scanner 코드에서 등장할 수 있는 문자([a-zA-Z0-9\\+\\&gt;\\&lt;\\=\\(\\)\\{\\}\\;]\\s)에 대하여 token이 될 수 있는 경우를 구분한다. 우선 +, &gt;, &lt;, =은 operator, {, }, (, ), ;은 separator, IF, THEN, ELSE, WHILE은 keyword로 분류한다. 그리고 [0-9]+은 num, keyword를 제외한 [a-zA-Z]+은 word로 분류한다. 분류한 내용을 바탕으로 다이어그램을 그린다. 원래는 NFA를 DFA로 고치고 이를 모두 구현해야했으나… Python을 사용하여 비교적 편하게 개발했다. Python은 set과 같은 자료구조를 따로 import하지 않아도 사용할 수 있고 사용법도 단순하여 쉽게 사용했다. 거기에 문자열 관련해서도 다른 언어에 비해 비교적 적은 코드를 사용하여 구현할 수 있기 때문에 Python을 사용하여 개발하기로 했다. 위에서 분류한 문자(열)에 따라 그 종류를 구분한다. 종류별로 해당되는 문자(열)를 변수에 저장하고 한 글자씩 읽으면서 토큰을 구성한다. 이 중에서 keyword는 문자가 아닌 특정한 문자열이므로 한 번에 여러 글자를 체크하여 keyword인지 체크해야 하고, num과 word는 같은 종류의 문자가 여러 번 나오므로 한 번 문자가 나왔을 때 그 뒤로 같은 종류인 위치까지 계속 읽어야 한다. 토큰을 구성하는 도중에 공백 문자가 나온다면 탐색을 중지하고 현재까지 읽은 문자열로 토큰을 만들어야 한다.6 여기에 Scanner의 기능 중 하나인 프로그램에 나타날 symbol을 저장하는 역할도 구현해야 한다. symbol은 word 토큰에서만 나올 수 있으므로 word 토큰을 읽을 때마다 이를 저장한다. 이를 고려해서 의사코드를 짜보면 아래와 같이 된다. separators = ['(', ')', '{', '}', ';'] operators = ['+', '&lt;', '&gt;', '='] keywords = [\"IF\", \"THEN\", \"ELSE\", \"WHILE\"] digits = ['0', '1', '2', ... , '9'] letters = ['A', 'B', 'C', ... , 'Z', 'a', 'b', ... ,'z'] whitespaces = [' ', '\\n', '\\r', '\\t'] tokens = [] symbols = set() while not input.eof(): l = 0 if input[0] in separators: tokens.append((\"separator\", input[0])) input.next(1) else if input[0] in operators: tokens.append((\"operator\", input[0])) input.next(1) else if input[0] in whitespaces: input.next(1) else if (l = is_keyword(input)): tokens.append((\"keyword\", input[0:l])) input.next(l) else if (l = is_num(input)): tokens.append((\"num\", input[0:l])) input.next(l) else if (l = is_word(input)): tokens.append((\"word\", input[0:l])) symbols.append(input[0:l]) input.next(l) fun is_keyword(input): keyword인 경우 해당하는 keyword의 길이를 반환 for keyword in keywords: l = keyword.length() if input[0:l] == keyword: return l return 0 fun is_num(input): num인 경우 길이를 반환 l = 0 while input[l] in digits: l++ return l fun is_word(input): word인 경우 길이를 반환 l = 0 while input[l] in letters: l++ return l 과제 당시에는 조금 급하게 만든 감이 없지 않아 있어서 불필요한 코드나 비효율적인 알고리즘이 일부 들어가있다. 소스 코드는 여기에서 볼 수 있다.(과제는 시간에 상관없이 돌아가기만 하면 됐다.) Parser 문법 조정 Parser에서는 토큰을 기반으로 문법이 맞는지 체크하기 때문에 토큰의 종류에 맞게 Parser용 문법을 만들어야 한다. 예를 들어, 과제의 문법에서 num ::= [0-9]+와 같은 규칙은 토큰과 전혀 상관없는 규칙이기 때문에 빼준다. 여기에 우변이 ε인 규칙은 처리하기 힘드므로 다른 규칙에 ε인 경우를 적용하여 제거해준다. 그러면 과제의 문법이 아래와 같이 조정된다. prog ::= word \"(\" \")\" block ; block ::= \"{\" slist \"}\" | \"{\" \"}\" ; slist ::= slist stat | stat ; stat ::= IF \"(\" cond \")\" THEN block ELSE block | WHILE \"(\" cond \")\" block | word \"=\" expr ';' ; cond ::= expr \"&gt;\" expr | expr \"&lt;\" expr ; expr ::= fact | expr \"+\" fact ; fact ::= num | word ; 이제 이 문법을 기반으로 다이어그램을 그려야 하는데, 위 문법을 그대로 쓰면 매우 복잡해지므로 약자를 사용한다. non-terminal은 대문자로, terminal은 소문자로 쓴다는 규칙을 적용하여 아래 표와 같이 변환시킨다. 수정 전 수정 후 수정 전 수정 후 prog P IF i block B THEN t slist L ELSE e stat S WHILE h cond C word w expr E num n fact F     이를 사용하여 문법을 production rule의 형식에 맞게 다시 적어보면 아래와 같다. (0) P -&gt; w \"(\" \")\" B (1) B -&gt; \"{\" L \"}\" (2) B -&gt; \"{\" \"}\" (3) L -&gt; L S (4) L -&gt; S (5) S -&gt; i \"(\" C \")\" t B e B (6) S -&gt; h \"(\" C \")\" B (7) S -&gt; w \"=\" E \";\" (8) C -&gt; E \"&gt;\" E (9) C -&gt; E \"&lt;\" E (10) E -&gt; F (11) E -&gt; E \"+\" F (12) F -&gt; n (13) F -&gt; w SLR parser 다이어그램 위에서 조정한 문법을 사용해서 SLR parser 다이어그램을 그려보면 아래와 같다. FIRST &amp; FOLLOW 집합 위의 문법을 기반으로 non-terminal의 FIRST와 FOLLOW 집합을 만들면 아래와 같이 된다. FIRST(P) = { w } FIRST(B) = { '{' } FIRST(L) = FIRST(S) = { i, h, w } FIRST(S) = { i, h, w } FIRST(C) = FIRST(E) = { n, w } FIRST(E) = FIRST(F) = { n, w } FIRST(F) = { n, w } FOLLOW(P) = { $ } FOLLOW(B) = { e } ∪ FOLLOW(P) ∪ FOLLOW(S) = { e, $, '}', i, h, w } FOLLOW(L) = { '}' } ∪ FIRST(S) = { '}', i, h, w } FOLLOW(S) = FOLLOW(L) = { '}', i, h, w } FOLLOW(C) = { ')' } FOLLOW(E) = { ';', '&gt;', '&lt;', '+'} ∪ FOLLOW(C) = { ';', '&gt;', '&lt;', '+', ')' } FOLLOW(F) = FOLLOW(E) = { ';', '&gt;', '&lt;', '+', ')' } Parsing Table 위에서 구한 SLR Parser의 다이어그램과 FOLLOW 집합을 사용하여 parsing table을 구해보면 아래와 같이 된다. 다이어그램 펼치기 숨기기 StateActionGoto nwiteh&gt;&lt;=+;(){}$BLSCEF 0S1 1S2 2S3 3S54 4Acc 5S11S9S10S678 6R2R2R2R2R2R2 7S11S9S10S1213 8R4R4R4R4 9S14 10S15 11S16 12R1R1R1R1R1R1 13R3R3R3R3 14S20S21171819 15S20S21221819 16S20S212319 17S24 18S26S25S27 19R10R10R10R10R10 20R12R12R12R12R12 21R13R13R13R13R13 22S28 23S27S29 24S30 25S20S213119 26S20S213219 27S20S2133 28S534 29R7R7R7R7 30S535 31S27R8 32S27R9 33R11R11R11R11R11 34R6R6R6R6 35S36 36S537 37R5R5R5R5 구현 Scanner는 Python을 사용하여 야매로(?) 구현했지만 Parser는 정직하게 구현한다. 먼저 위에서 구성한 Parsing Table을 그대로 옮긴다. 각 state별로 dict를 하나씩 할당하여 Action과 Goto 상관없이 입력받은 non-terminal와 terminal에 따른 행동을 저장한다. 예를 들어, 0번 state의 변수는 {'w': 'S1'}이 된다. 이를 사용하여 PDA의 작동 방식 그대로 파싱을 구현한다. 여기에 추가적으로 Symbol Table의 각 symbol마다 scope도 정해주어야 한다. 이 작업은 Parsing Tree를 구성한 후 tree의 depth를 사용하여 구하면 편하므로 파싱 과정에서 parsing tree를 만들도록 한다. 이 과정을 의사 코드로 작성하면 아래와 같이 된다. table = [{'w': ['S', 1]}, {'(', ['S', 2]}, ...] grammar = [['P', \"w()B\"], ['B', \"{L}\"], ['B', \"{}\"], ...] state = 0 stack = [0] nodes = [] while i &lt; tokens.length(): action = table[state][tokens[i].type] if action == None: throw error(\"Parsing Error: Unexpected token(\" + tokens[i] + \")\") if action[0] == 'A': Accept break else if action[0] == 'S': Stack state = action[1] stack.push(tokens[i]) stack.push(state) Parsing tree node = {\"value\": tokens[i].value} nodes.append(node) else if action[0] == 'R': Reduce gram = grammar[action[1]] action = table[state][gram[0]] for i in range(0, 2 * gram[1].length()): stack.pop() stack.push(gram[0]) stack.push(action[1]) Parsing tree node = {\"value\": tokens[i].value, \"children\": nodes[-gram[1].length():0]} nodes = nodes[0:nodes.length() - gram[1].length()] nodes.append(node) root = {} root.value = grammar[0][0] root.children = nodes 위 코드에서 사용된 tokens 변수는 토큰의 종류와 실제 값을 dict 형식으로 저장한 변수의 배열이다. 종류와 실제 값이 둘 다 필요한 이유는 num 토큰이나 word 토큰이 parsing 과정(문법 체크 과정)에서는 종류, symbol table 구성 과정에서는 토큰의 실제 값을 사용하기 때문이다. 나머지 토큰은 type과 value가 같다. 위 코드의 동작이 끝나면 root 변수에 parsing tree가 생긴다. 이를 사용하여 각 symbol의 유효 scope를 찾는다. 중괄호 토큰이 나오면 그에 맞게 scope를 조정하고, symbol을 정의하는 구문(w=E;)이 나오면 symbol table의 symbol 항목에 scope를 저장한다. 그 과정은 아래의 의사 코드와 같다. stack = [root] level = -1 scope = [] current = {} prev = {} while not stack.empty(): prev = current current = stack.pop() if current.value == '{': level += 1 if scope.length() &lt; level + 1: scope.append(0) scope[level] += 1 for i in range(level + 1, scope.length()): scope[i] = 1 else if current.value == '}': level -= 1 else if current.value == '=': symbol_table.set_scope(prev.value, scope[0:level+1].join(\".\")) if current.children != null: for i in range(current.length() - 1, -1, -1): stack.push(current.children[i]) 실제 코드에서는 위와 같은 방법을 그대로 사용하지는 않았다. tokens로 넘어오는 정보의 종류도 약간 다르고, 그에 따라 처리하는 방법도 약간 다르며 scope를 처리하는 부분도 약간 다르다. 실제로 사용한 코드는 여기에서 볼 수 있다. Code Generator Parser에서 생성된 parsing tree를 사용하여 어셈블리와 닮은 목표 언어로 변환한다. 과제에서 목표 언어와 관련되어 제시된 내용은 아래와 같다. Pseudocode Instructions LD Reg#1, addr(or num) | Reg#1에 변수 또는 값을 로드 ST Reg#1, addr | Reg#1의 값을 변수에 저장 ADD Reg#1, Reg#2, Reg#3 | Reg#1 = Reg#2 + Reg#3 LT Reg#1, Reg#2, Reg#3 | Reg#2 &lt; Reg#3이면 1을, 아니면 0을 Reg#1에 저장 JUMPF Reg#1, label | Reg#1이 0이면 label로 점프 JUMPT Reg#1, label | Reg#1이 0이 아니면 label로 점프 JUMP label | label로 점프 MV Reg#1, Reg#2 | Reg#1의 값을 Reg#2에 설정 함수는 BEGIN 이름으로 시작하고 END 이름으로 종료 사용하는 레지스터의 개수를 최소화, 사용한 레지스터의 개수 출력 우선 목표 언어 변환할 statement를 설정해놓은 다음 parsing tree를 순회하면서 해당 statement를 목표 언어로 변환하는 방법을 사용할 수 있다. 예를 들어 h(C)B 구문이 나오면 JUMPF instruction을 활용할 수 있다. 그리고 해당 구문 안의 C나 B 같은 부분은 해당 부분을 따로 목표 언어로 만든 뒤 기존 코드에 붙이면 된다. 간단하게 설명하면 아래와 같다. .L1: (C에 해당하는 코드, 결과를 Reg#1에 저장) JUMPF Reg#1, .L2 (B에 해당하는 코드) JUMP .L1 .L2: 이러한 식으로 목표 언어로 변환할 수 있다. 이를 구문 별로 어떻게 할지 정해놓고 parsing tree를 순회하면서 목표 언어를 만들면 된다. symbol의 경우 symbol table에 해당 symbol을 저장할 주소를 넣어놓고 사용하면 된다. 이를 의사 코드로 표현하면 아래와 같다. current = {} reg = 1 label = 1 addr = 0 max_reg = 0 fun gen_code(node): code = \"\" if node.type == 'P': P -&gt; w()B code = \"BEGIN \" + node.children[0].value + \"\\n\" code += gen_code(node.children[3]) B code += \"END \" + node.children[0].value + \"\\n\" return code if node.type == 'B': if node.children.length() == 2: B -&gt; { } return \"\" return gen_code(node.children[1]) B -&gt; { L } else if node.type == 'L': code = gen_code(node.children[0]) L or S if node.children.length() == 2: L -&gt; L S code += gen_code(node.children[1]) return code else if node.type == 'S': if node.children[0].type == 'i': S -&gt; i ( C ) t B e B code += gen_code(node.children[2]) C code += \"JUMPF Reg#\" + reg + \" .L\" + label + \"\\n\" code += gen_code(node.children[5]) B1 code += \"JUMP .L\" + (label + 1) + \"\\n\" code += \".L\" + label + \"\\n\" code += gen_code(node.children[7]) B2 code += \".L\" + (label + 1) + \"\\n\" label += 2 else if node.children[0].type == 'h': S -&gt; h ( C ) B code += \".L\" + label + \"\\n\" code += gen_code(node.children[2]) C code += \"JUMPF Reg#\" + reg + \" .L\" + (label + 1) + \"\\n\" code += gen_code(node.children[4]) B code += \"JUMP .L\" + label + \"\\n\" code += \".L\" + (label + 1) + \"\\n\" label += 2 else: S -&gt; w = E ; code = gen_code(node.children[2]) E code += \"ST Reg#\" + reg + \" \" + addr + \"\\n\" table.set_addr(node.children[0].value, addr) addr += 4 max_reg = max(max_reg, reg) return code else if node.type == 'C': code = gen_code(node.children[0]) E1 reg += 1 code += gen_code(node.children[2]) E2 reg -= 1 if node.children[1].value == '&lt;': C -&gt; E &lt; E code += \"LT Reg#\" + reg + \" Reg#\" + reg + \" Reg#\" + (reg + 1) + \"\\n\" else: C -&gt; E &gt; E code += \"LT Reg#\" + reg + \" Reg#\" + (reg + 1) + \" Reg#\" + reg + \"\\n\" max_reg = max(max_reg, reg + 1) return code else if node.type == 'E': if node.children[0].type == 'E': E -&gt; E + F code = gen_code(node.children[0]) E reg += 1 code = gen_code(node.children[2]) F reg -= 1 code += \"ADD Reg#\" + reg + \" Reg#\" + reg + \" Reg#\" + (reg + 1) + \"\\n\" max_reg = max(max_reg, reg + 1) return code else: E -&gt; F return gen_code(node.children[0]) F else if node.type == 'F': if node.children[0].type == 'w': F -&gt; w code = \"LD Reg#\" + reg + \" \" + table.get_addr(node.children[0].value) + \"\\n\" else: F -&gt; n code = \"LD Reg#\" + reg + \" \" + node.children[0].value + \"\\n\" max_reg = max(max_reg, reg) return code print(gen_code(root)) 위와 같은 방식을 사용하여 목표 언어와 사용한 레지스터의 개수를 출력할 수 있다. 레지스터의 개수를 최소화하는 방법은 모든 변수를 ST와 LD를 사용하여 필요할 때마다 꺼내쓰는 것이다. 변수를 저장하는 구문은 w=E;밖에 없기 때문에 여기서 무조건 ST를 실행시키면 레지스터를 아무리 사용하더라도 값을 안전하게 저장할 수 있다. 여기에 시작 언어가 변수를 새로 선언하는 구문이 없는 언어이므로 scope를 신경쓰지 않고 해당 이름을 가지는 변수가 유일하게 존재한다고 가정해도 된다. 과제로 이를 구현할 때는 돌아가기만 하면 됐기 때문에 조금 오류가 있을 수도 있다. 당시 작성한 파일은 여기에서 볼 수 있다. Result 내용 추가 예정 Regular Expression, 줄여서 Regex라고 한다. 기본적인 regex(문자(열)와 Concatenation, Alternation, Kleene Star의 3가지 연산의 조합으로 이루어진 regex)는 유한 상태 오토마타로 변환이 가능하고 역과정도 가능하다. &#8617; set 자료구조를 사용하여 NFA를 구현할 수 있다.↗ DFA에서 현재 상태를 하나의 변수로 저장하는 것을 NFA에서 현재 가진 상태를 set에 저장하는 방법이다. 전이함수를 나타내는 변수만 NFA에 맞게 새로 정의하면 나머지는 DFA와 크게 차이가 없을 것 같다. &#8617; 전이 함수의 정의만 따져보면 정의역이 Q×Σ이기 때문에 여기에 속하는 모든 원소에 대해서 함수값을 정의해야 할 것처럼 보이지만 꼭 그렇지는 않다. DFA에서 나올 수 있는 조합에 대해서만 함수값이 정의되어도 DFA는 오류 없이 잘 작동한다. &#8617; 대입 연산자가 아니더라도 스캔 과정에서 등장하는 모든 word는 Symbol Table에 넣으면 된다. Parser가 동작하면서 scope가 정의되지 않는 symbol이 있거나 선언에 의해 정해진 symbol의 scope 밖에서 symbol이 등장하면 에러를 출력하면 된다. 이 글을 작성하는 과정에서 헷갈려서 위키피디아를 찾아보니 대입 연산자 앞에 있는 토큰만 처리한다는 조건은 적혀있지 않았다. &#8617; 경우에 따라서 FIRST 집합도 사용한다. FIRST 집합은 non-terminal을 구성하는 첫 번째 terminal로서 올 수 있는 terminal의 집합이다. SLR parsing 과정 자체에서는 FIRST를 사용하지 않지만, FOLLOW 집합을 구할 때 유용하게 사용할 수 있다. 문법의 규칙 중 우변에서 non-terminal이 연달아 나오는 경우에 FIRST 집합이 쓸모있다. 예를 들어 E → T F라는 규칙이 있을 때, FOLLOW(T)는 항상 FIRST(F)를 부분집합으로 가진다. 예시로 제시한 문법은 이러한 경우가 없었지만 과제의 문법은 이러한 경우가 있으므로 여기서는 서술하지 않지만 과제 결과물 구상에서는 이를 사용할 것이다. &#8617; 조금 더 구체적으로 설명하자면, abc de라는 문자열을 처리해야 한다고 하자. a를 읽은 시점에서 word 토큰을 구성하기 시작한다. b와 c를 읽은 후 공백 문자를 입력받게 되는데, 이 때에는 abc에서 끊고 이를 하나의 word 토큰으로 인식해야 한다. 공백 문자 이후의 문자열인 de를 읽고나면 위 문자열은 abcde라는 word 토큰이 아닌 abc와 de의 2개의 word 토큰으로 인식해야 하는 것이다. &#8617;"
					}

					
				
			
		
			
				
					,
					

					"ko-404": {
						"id": "ko-404",
						"title": "여긴 어디죠?",
						"category": "",
						"url": " /ko/404/",
						"content": "저런! 존재하지 않는 페이지입니다!"
					}

					
				
			
		
			
				
					,
					

					"ko": {
						"id": "ko",
						"title": "환영합니다!",
						"category": "",
						"url": " /ko/",
						"content": "이 사이트는 Orb_H가 진행한 일정 규모 이상의 프로젝트를 정리해놓는 사이트입니다. 팀 프로젝트와 개인 프로젝트를 모두 포함합니다. 페이지 구조 페이지는 크게 왼쪽 사이드 바와 본문으로 나뉩니다. 사이드 바 사이드 바는 크게 다섯 부분으로 나뉘는데, 위에서부터 각각 닉네임 및 로고, 검색, 메인 페이지, 카테고리 및 페이지, 외부 링크입니다. 닉네임 및 로고 제 로고와 닉네임입니다. 검색 검색을 할 수 있습니다. 텍스트 입력 칸에 원하는 텍스트를 입력하고 엔터키를 누르면 본문에 해당 텍스트를 포함하는 모든 문서를 나열합니다. 메인 페이지 메인 페이지를 가리키는 링크입니다. 카테고리 및 페이지 각 페이지의 카테고리에 따라 분류가 되어있으며, 내부적으로 지정된 순서대로 페이지가 카테고리별로 나열됩니다. 이 사이트의 경우 카테고리는 프로젝트를 진행한 연도이므로 각 연도별로 진행한 프로젝트가 순서대로 나열됩니다. 외부 링크 제 사이트(orb-h.github.io) 아래의 다른 서브 페이지들과 이 사이트의 테마가 올라와있는 리포지토리 등 여러 링크가 있습니다. 본문 본문은 크게 네 부분으로 나뉘는데, 위에서부터 각각 카테고리, 페이지 제목, 언어 선택, 내용입니다. 카테고리 해당 페이지의 카테고리를 표시합니다. 메인 페이지나 검색 페이지의 경우 카테고리가 존재하지 않아 제 닉네임이 나옵니다. 페이지 제목 해당 페이지의 제목을 표시합니다. 언어 선택 우측 정렬이 되어있으며, 이 사이트에서 지원하는 언어 중 원하는 언어를 선택할 수 있습니다. 내용 해당 페이지의 내용입니다. 프로젝트 목록 작성 완료된 프로젝트 연도 제목 비고       작성중인 프로젝트 진행률 연도 제목 비고 2016~7 산-염기 적정 시뮬레이션 고2 토이 프로젝트 고등학교 졸업논문 2019 코드 변환기 2019-2 프로그래밍언어 과목 과제 2021 Project Prism 군대 사지방에서 제작하다가 중단한 리듬게임 작성 예정인 프로젝트 연도 제목 비고 2017 Coconuts 고등학교 자습실 신청 사이트 대체용 어플리케이션 및 자동신청 시스템 2019 SKKOIN 성균관대학교 암호화폐 개발, 산학협력프로젝트 과목 프로젝트 2016 covista(); Arduino를 사용한 초저가형 3D 스캐너, 고등학교 2학년 정보과학프로젝트 과목 수행평가 2017,2020 ProbieLang 인터프리터 Java, JS 2018,2019 테트리스(Java) 토이 프로젝트 2019-1 JAVA프로그래밍실습 과목 과제 제출 실패(조건 부적합) 2019 TBS(Turn-Based Strategy) Card Battle Game 2019-1 JAVA프로그래밍실습 과목 과제 2019 문제해결기법 과제 모음 2019-2 문제해결기법 과목 과제 2020,2021 근무생성기.cell 군대에서 불침번 및 초소 근무 생성 자동화를 목표로 만든 한셀 파일 2021 테트리스(JS) 토이 프로젝트 군대에서 제작 2015 H-owler(ProjectLCK) 고등학교 기숙사를 모티브로 한 추격 게임, 마인크래프트 플러그인"
					}

					
				
			
		
			
				
					,
					

					"ko-search": {
						"id": "ko-search",
						"title": "검색",
						"category": "",
						"url": " /ko/search/",
						"content": "{% include search.html lang=page.lang %}"
					}

					
				
			
		
	};
</script>

<script src="/projects/scripts/lunr.min.js" charset="utf-8"></script>

<script src="/projects/scripts/search.js" charset="utf-8" found=":" not_found=" 없음"></script>


			</article>
		</section>

		<script>
			document.getElementById("open-nav").addEventListener("click", function () {
				document.body.classList.toggle("nav-open");
			});
		</script>
	</body>
</html>
